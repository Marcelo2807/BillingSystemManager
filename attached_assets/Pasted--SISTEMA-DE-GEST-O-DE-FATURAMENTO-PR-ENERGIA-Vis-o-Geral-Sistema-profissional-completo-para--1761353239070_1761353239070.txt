üìä SISTEMA DE GEST√ÉO DE FATURAMENTO PR√ì ENERGIA
üéØ Vis√£o Geral
Sistema profissional completo para gest√£o de faturamento de energia solar, com processamento inteligente de documentos usando IA, gerenciamento de consumidores, unidades consumidoras, usinas solares e envio automatizado de faturas por email.
üèóÔ∏è Arquitetura Tecnol√≥gica
Frontend
Framework: React 18.3.1 + TypeScript
Build Tool: Vite
Routing: React Router DOM v6.30.1
UI Components: Radix UI + shadcn/ui
Styling: Tailwind CSS + tailwindcss-animate
State Management: TanStack Query (React Query) v5.83.0
Forms: React Hook Form + Zod validation
Charts: Recharts v2.15.4
Export: jsPDF + XLSX
Backend
BaaS: Supabase (Lovable Cloud)
Database: PostgreSQL
Storage: Supabase Storage (3 buckets)
Edge Functions: Deno (8 functions)
Auth: Supabase Auth
IA & Integrations
Lovable AI: Google Gemini 2.5 Flash (extra√ß√£o de faturas)
OpenAI: GPT-4o-mini (processamento gen√©rico de documentos)
Email: Resend (envio transacional)
üìÅ Estrutura do Banco de Dados
Tabelas Principais (10 tabelas)
-- Cadastros B√°sicos
‚îú‚îÄ‚îÄ consumers (consumidores)
‚îÇ ‚îú‚îÄ‚îÄ id, name, email, phone, document
‚îÇ ‚îî‚îÄ‚îÄ RLS: owner_can_* policies
‚îÇ
‚îú‚îÄ‚îÄ units (unidades consumidoras)
‚îÇ ‚îú‚îÄ‚îÄ id, uc_number, distributor, consumer_id, plant_id
‚îÇ ‚îî‚îÄ‚îÄ Relacionamento: N:1 com consumers e plants
‚îÇ
‚îú‚îÄ‚îÄ plants (usinas solares)
‚îÇ ‚îú‚îÄ‚îÄ id, name, cnpj, city, state
‚îÇ ‚îî‚îÄ‚îÄ RLS: owner_can_* policies
‚îÇ
-- Faturamento
‚îú‚îÄ‚îÄ invoices (faturas)
‚îÇ ‚îú‚îÄ‚îÄ id, type (distributor|proprietary)
‚îÇ ‚îú‚îÄ‚îÄ storage_path, sha256, status, parsed (JSONB)
‚îÇ ‚îú‚îÄ‚îÄ amount_total, due_date, kwh_compensated
‚îÇ ‚îî‚îÄ‚îÄ reference_month, reference_year
‚îÇ
‚îú‚îÄ‚îÄ billing_records (registros de cobran√ßa)
‚îÇ ‚îú‚îÄ‚îÄ id, invoice_id, consumer_id, status
‚îÇ ‚îú‚îÄ‚îÄ asaas_customer_id, asaas_payment_id
‚îÇ ‚îî‚îÄ‚îÄ pix_payload, pix_base64
‚îÇ
-- Rateios e Performance
‚îú‚îÄ‚îÄ apportionments (rateios)
‚îÇ ‚îú‚îÄ‚îÄ id, plant_id, unit_id, percent
‚îÇ ‚îî‚îÄ‚îÄ valid_from, valid_to
‚îÇ
‚îú‚îÄ‚îÄ performance_records (rendimento)
‚îÇ ‚îú‚îÄ‚îÄ energy_consumed, energy_compensated
‚îÇ ‚îú‚îÄ‚îÄ billing, consumer_savings
‚îÇ ‚îî‚îÄ‚îÄ reference_month
‚îÇ
-- IA & Documentos
‚îú‚îÄ‚îÄ documents (documentos gen√©ricos)
‚îÇ ‚îú‚îÄ‚îÄ id, bucket, path, processing
‚îÇ ‚îî‚îÄ‚îÄ uploaded_by, size_bytes
‚îÇ
‚îú‚îÄ‚îÄ document_extractions (extra√ß√µes de IA)
‚îÇ ‚îú‚îÄ‚îÄ id, document_id, doc_type
‚îÇ ‚îú‚îÄ‚îÄ json_data (JSONB), confidence
‚îÇ ‚îî‚îÄ‚îÄ RLS: all_* policies
‚îÇ
-- Email & Templates
‚îú‚îÄ‚îÄ email_history (hist√≥rico de emails)
‚îÇ ‚îú‚îÄ‚îÄ id, to_email, subject, status
‚îÇ ‚îú‚îÄ‚îÄ attachments (JSONB), html_preview
‚îÇ ‚îî‚îÄ‚îÄ provider_message_id
‚îÇ
‚îî‚îÄ‚îÄ email_templates (templates de email)
‚îú‚îÄ‚îÄ id, slug, html, schema_version
‚îî‚îÄ‚îÄ RLS: templates_readable/writable
Storage Buckets
invoices (privado) ‚Üí Faturas de energia
generated-invoices (privado) ‚Üí PDFs gerados
documents (privado) ‚Üí Documentos gen√©ricos processados por IA
üöÄ Funcionalidades Principais
Dashboard üìä
Rota: /
C√≥digo:
// src/pages/Dashboard.tsx
const Dashboard = () => {
const { data: billingRecords } = useQuery({
queryKey: ["billing-records-dashboard"],
queryFn: async () => {
const { data } = await supabase
.from("billing_records")
.select(id, created_at, status, invoice:invoices(due_date, amount_total, unit:units(uc_number)), consumer:consumers(document))
.order("created_at", { ascending: false })
.limit(50);
return data;
},
staleTime: 30000, // Cache 30s
});
return (
<div>
<StatsCard title="Total de Consumidores" value={totalConsumers} icon={Users} />
<StatsCard title="Unidades Consumidoras" value={totalUnits} icon={Building2} />
<StatsCard title="Faturas do M√™s" value={billingsThisMonth} icon={FileText} />
<StatsCard title="Total a Receber" value={formatCurrency(totalReceivable)} icon={DollarSign} />
code
Code
<AlertsSection type="overdue" billings={overdueBillings} />
  <AlertsSection type="upcoming" billings={upcomingBillings} />
  
  <RecentBillingTable billings={records} />
</div>
);
};
Features:
‚úÖ Cards com m√©tricas principais (consumidores, unidades, faturas, valor a receber)
‚úÖ Alertas de faturas vencidas e pr√≥ximas do vencimento
‚úÖ Tabela de faturas recentes
‚úÖ Cache inteligente (30s) com React Query
2. Gest√£o de Consumidores üë•
Rota: /consumers
C√≥digo:
// src/pages/Consumers.tsx + src/hooks/useConsumers.ts
export function useConsumers() {
const { data: consumers, isLoading } = useQuery({
queryKey: ["consumers"],
queryFn: async () => {
const { data, error } = await supabase
.from("consumers")
.select("*")
.order("name");
if (error) throw error;
return data;
},
staleTime: 120000, // Cache 2min
retry: 2, // Retry autom√°tico
});
const createMutation = useMutation({
mutationFn: async (newConsumer: any) => {
const { data } = await supabase
.from("consumers")
.insert(newConsumer)
.select()
.single();
return data;
},
onSuccess: () => {
queryClient.invalidateQueries({ queryKey: ["consumers"] });
toast({ title: "Consumidor criado com sucesso!" });
},
});
return { consumers, isLoading, create: createMutation.mutate };
}
Features:
‚úÖ CRUD completo de consumidores
‚úÖ Busca por nome, CPF/CNPJ, email
‚úÖ Ordena√ß√£o din√¢mica (nome, email)
‚úÖ Pagina√ß√£o (20 itens/p√°gina)
‚úÖ Badge mostrando quantidade de unidades consumidoras
‚úÖ Dialog de cria√ß√£o/edi√ß√£o com valida√ß√£o
3. Unidades Consumidoras üè¢
Rota: /units
C√≥digo:
// src/pages/Units.tsx
const Units = () => {
const { units } = useUnits();
const { consumers } = useConsumers();
const filteredUnits = units.filter((unit) => {
const matchesSearch = unit.uc_number.includes(searchTerm);
const matchesCompany = selectedCompanies.length === 0 ||
selectedCompanies.includes(unit.distributor);
return matchesSearch && matchesCompany;
});
return (
<div>
<UnitsFilters
selectedCompanies={selectedCompanies}
onCompaniesChange={setSelectedCompanies}
allCompanies={uniqueCompanies}
/>
code
Code
<Table>
    <TableBody>
      {paginatedUnits.map((unit) => (
        <TableRow onClick={() => navigate(`/units/${unit.id}`)}>
          <TableCell>{unit.uc_number}</TableCell>
          <TableCell>{getConsumerName(unit.consumer_id)}</TableCell>
          <TableCell><Badge>{unit.distributor}</Badge></TableCell>
        </TableRow>
      ))}
    </TableBody>
  </Table>
</div>
);
};
Features:
‚úÖ Listagem com filtros avan√ßados (distribuidora, empresa, associa√ß√£o)
‚úÖ Relacionamento com consumidores e usinas
‚úÖ Endere√ßo completo (armazenado em JSONB)
‚úÖ P√°gina de detalhes com hist√≥rico de faturas
4. Usinas Solares ‚òÄÔ∏è
Rota: /plants
C√≥digo:
// src/pages/Plants.tsx
export default function Plants() {
const { plants, create, update } = usePlants();
return (
<div>
<Table>
<TableBody>
{plants.map((plant) => (
<TableRow onClick={() => navigate(/plants/${plant.id})}>
<TableCell>
<Sun className="h-4 w-4 text-primary" />
{plant.name}
</TableCell>
<TableCell>{plant.cnpj}</TableCell>
<TableCell><Badge>{plant.city}</Badge></TableCell>
<TableCell>{plant.state}</TableCell>
</TableRow>
))}
</TableBody>
</Table>
code
Code
<PlantDialog mode="create" onSave={create} />
</div>
);
}
Features:
‚úÖ Cadastro de usinas com CNPJ, localiza√ß√£o
‚úÖ P√°gina de detalhes com estat√≠sticas
‚úÖ Relacionamento com unidades consumidoras
5. Upload & Processamento de Faturas (IA) üìÑü§ñ
Rota: /billing/upload-invoices
Fluxo Completo:
Frontend (InvoiceUploadZone.tsx):
const handleUpload = async () => {
for (const file of files) {
// 1. Calcula SHA256 para deduplica√ß√£o
const sha256 = await calculateSHA256(file);
code
Code
// 2. Upload para Supabase Storage
const filePath = `${session.user.id}/${Date.now()}-${file.name}`;
await supabase.storage.from("invoices").upload(filePath, file);

// 3. Cria registro na tabela invoices
const { data: invoice } = await supabase
  .from("invoices")
  .upsert({
    type: invoiceType === "solar" ? "proprietary" : "distributor",
    storage_path: filePath,
    sha256, // Chave √∫nica para evitar duplicatas
    status: "uploaded",
    reference_month, reference_year
  }, { onConflict: "sha256", ignoreDuplicates: false })
  .select()
  .single();

// 4. Dispara extra√ß√£o com IA (com retry autom√°tico)
let retries = 0;
while (retries < 3) {
  const { error } = await supabase.functions.invoke("extract-invoice-data", {
    body: { invoiceId: invoice.id, storagePath: filePath, type: invoiceType }
  });
  
  if (!error) break;
  if (error.message.includes("Rate limit")) {
    await sleep(2 ** retries * 1000); // Exponential backoff
    retries++;
  } else break;
}
}
};
Backend (extract-invoice-data/index.ts):
// supabase/functions/extract-invoice-data/index.ts
serve(async (req) => {
const { invoiceId, storagePath } = await req.json();
// 1) Download PDF e converte para base64
const pdfB64 = await downloadFileAsBase64(supabase, "invoices", storagePath);
// 2) Chama Lovable AI (Gemini 2.5 Flash) com timeout de 120s + 2 retries
const prompt = Extraia os seguintes campos desta fatura: { "uc_number", "distributor", "reference_month", "due_date", "amount_total", "kwh_compensated", "band" };
const aiResponse = await withRetryAndTimeout(
() => fetch("https://ai.gateway.lovable.dev/v1/chat/completions", {
method: "POST",
headers: { "Authorization": Bearer ${LOVABLE_API_KEY} },
body: JSON.stringify({
model: "google/gemini-2.5-flash",
messages: [{
role: "user",
content: [
{ type: "text", text: prompt },
{ type: "image_url", image_url: {
url: data:application/pdf;base64,${pdfB64}
}}
]
}]
})
}),
{ maxRetries: 2, timeout: 120000 } // 120s timeout, 2 retries
);
const aiResult = await aiResponse.json();
const extracted = JSON.parse(aiResult.choices[0].message.content);
// 3) Atualiza invoice com dados extra√≠dos
await supabase.from("invoices").update({
parsed: extracted,
band: extracted.band,
due_date: extracted.due_date,
amount_total: extracted.amount_total,
status: "parsed"
}).eq("id", invoiceId);
return json({ ok: true, parsed: extracted });
});
Features:
‚úÖ Drag & drop ou sele√ß√£o m√∫ltipla
‚úÖ Valida√ß√£o (PDF/PNG/JPG/WEBP, m√°x 5MB)
‚úÖ Deduplica√ß√£o via SHA256
‚úÖ Extra√ß√£o autom√°tica com IA (Gemini 2.5 Flash)
‚úÖ Retry autom√°tico com exponential backoff
‚úÖ Tratamento de rate limits (429) e cr√©ditos (402)
‚úÖ Timeout de 120s para arquivos grandes
‚úÖ Tabs separadas: Usinas / Unidades
6. Envio de Emails em Massa ‚úâÔ∏è
Rota: /send-emails
C√≥digo:
// src/pages/SendEmails.tsx
const SendEmails = () => {
const [selectedBillings, setSelectedBillings] = useState<string[]>([]);
const [emailMessage, setEmailMessage] = useState("Prezado(a) cliente...");
const sendEmailMutation = useMutation({
mutationFn: async (billingIds: string[]) => {
const validRecords = billingIds
.map(id => billingRecords.find(r => r.id === id))
.filter(r => r?.consumer?.email?.includes("@"));
code
Code
const promises = validRecords.map(record =>
    supabase.functions.invoke("send-custom-invoice", {
      body: {
        invoiceId: record.invoice_id,
        distributorInvoiceId: record.distributor_invoice_id,
        to: [record.consumer.email],
        customMessage: emailMessage,
        consumer: {
          name: record.consumer.name,
          email: record.consumer.email,
          cpfCnpj: record.consumer.document,
          mobilePhone: record.consumer.phone
        }
      }
    })
  );
  
  return Promise.allSettled(promises);
},
onSuccess: (results) => {
  const succeeded = results.filter(r => r.status === 'fulfilled').length;
  toast({ title: `${succeeded} email(s) enviado(s)!` });
}
});
return (
<div>
<Select value={filterStatus} onValueChange={setFilterStatus}>
<SelectItem value="pending">Pendentes</SelectItem>
<SelectItem value="paid">Pagos</SelectItem>
<SelectItem value="overdue">Vencidos</SelectItem>
</Select>
code
Code
<Card>
    {unpaidBillings.map((billing) => (
      <div onClick={() => handleSelectBilling(billing.id)}>
        <Checkbox checked={selectedBillings.includes(billing.id)} />
        <span>{billing.unitName}</span>
        <span>{formatCurrency(billing.amountDue)}</span>
      </div>
    ))}
  </Card>
  
  <Textarea value={emailMessage} onChange={(e) => setEmailMessage(e.target.value)} />
  <Button onClick={() => sendEmailMutation.mutate(selectedBillings)}>
    Enviar Emails
  </Button>
  
  <EmailHistoryCard />
</div>
);
};
Edge Function (send-custom-invoice):
// supabase/functions/send-custom-invoice/index.ts
serve(async (req) => {
const { invoiceId, distributorInvoiceId, to, customMessage, consumer } = await req.json();
// 1) Busca dados das faturas
const [proprietary, distributor] = await Promise.all([
supabase.from("invoices").select("").eq("id", invoiceId).single(),
supabase.from("invoices").select("").eq("id", distributorInvoiceId).single()
]);
// 2) Baixa PDFs e converte para base64
const enelPdfB64 = await downloadToBase64("invoices", distributor.storage_path);
const demoPdfB64 = await downloadToBase64("invoices", proprietary.storage_path);
// 3) Valida tamanho total (m√°x 25MB)
const totalSize = ((enelPdfB64.length + demoPdfB64.length) * 3) / 4;
if (totalSize > 25 * 1024 * 1024) {
throw new Error(Anexos muito grandes: ${(totalSize/(1024*1024)).toFixed(2)}MB);
}
// 4) Envia via Resend
const sent = await resend.sendEmail({
from: EMAIL_FROM,
to,
subject: Fatura ${ref} ‚Äì UC ${proprietary.parsed?.uc_number},
html: ProInvoiceEmail({ consumer, customMessage }),
attachments: [
{ filename: "Fatura-Distribuidora.pdf", content: enelPdfB64 },
{ filename: "Demonstrativo-Pro-Energia.pdf", content: demoPdfB64 }
]
});
if (!sent || !sent.id) {
throw new Error("Falha ao enviar email via Resend");
}
// 5) Atualiza status
await supabase.from("billing_records").update({ status: "sent" }).eq("id", billingRecordId);
await supabase.from("email_history").insert({ to_email: to.join(","), status: "sent" });
return json({ ok: true, messageId: sent.id });
});
Features:
‚úÖ Sele√ß√£o m√∫ltipla com checkbox
‚úÖ Filtros: per√≠odo, status, consumidor
‚úÖ Mensagem personalizada
‚úÖ Anexo autom√°tico de 2 PDFs (distribuidora + demonstrativo)
‚úÖ Valida√ß√£o de tamanho (m√°x 25MB)
‚úÖ Hist√≥rico de envios com preview HTML
‚úÖ Tratamento de erros (valida√ß√£o de email, Resend failures)
7. Rateios de Energia üîÄ
Rota: /apportionments
C√≥digo:
// src/pages/Apportionments.tsx
export default function Apportionments() {
const { apportionments, create, update } = useApportionments();
return (
<div>
<Card>
<CardTitle>Rateios Ativos: {stats.totalActive}</CardTitle>
<CardTitle>Usinas com Rateio: {stats.totalPlants}</CardTitle>
<CardTitle>Total de Consumidores: {stats.totalConsumers}</CardTitle>
</Card>
code
Code
<ApportionmentTable
    apportionments={filteredApportionments}
    onViewDetails={handleViewDetails}
    onEdit={handleEdit}
    onDuplicate={handleDuplicate}
    onDeactivate={handleDeactivate}
  />
  
  <ApportionmentDialog onSave={handleSave} />
  <ApportionmentHistoryDialog apportionmentId={selectedId} />
</div>
);
}
Features:
‚úÖ Distribui√ß√£o percentual de energia entre consumidores
‚úÖ Versionamento (valid_from / valid_to)
‚úÖ Status: draft, active, inactive
‚úÖ Hist√≥rico completo de altera√ß√µes
‚úÖ Duplica√ß√£o de rateios
‚úÖ C√°lculo autom√°tico de totais (100%)
8. Relat√≥rios & Exporta√ß√£o üìà
Rota: /reports
C√≥digo:
// src/pages/Reports.tsx
const Reports = () => {
const handleExport = (format: string) => {
if (format === 'excel') {
const exportData = records.map(r => ({
'Unidade': r.unitName,
'Valor': r.amountDue,
'Vencimento': new Date(r.dueDate).toLocaleDateString("pt-BR"),
'Status': r.status
}));
code
Code
const worksheet = XLSX.utils.json_to_sheet(exportData);
  const workbook = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(workbook, worksheet, "Relat√≥rio");
  XLSX.writeFile(workbook, `relatorio-faturamento-${date}.xlsx`);
}

if (format === 'pdf') {
  const doc = new jsPDF();
  doc.text("Relat√≥rio de Faturamento", 14, 20);
  doc.text(`Total de Faturas: ${totalBillings}`, 14, 35);
  doc.text(`Valor Total: ${formatCurrency(totalValue)}`, 14, 42);
  // ... mais detalhes
  doc.save(`relatorio-${date}.pdf`);
}
};
return (
<div>
<Card><CardTitle>Total de Faturas: {totalBillings}</CardTitle></Card>
<Card><CardTitle>Valor Total: {formatCurrency(totalValue)}</CardTitle></Card>
<Card><CardTitle>Faturas Pagas: {paidBillings}</CardTitle></Card>
<Card><CardTitle>Faturas Vencidas: {overdueBillings}</CardTitle></Card>
code
Code
<Card>
    <CardTitle>Distribui√ß√£o por Status</CardTitle>
    {/* Gr√°ficos de barras com percentuais */}
  </Card>
  
  <Button onClick={() => handleExport("excel")}>Exportar Excel</Button>
  <Button onClick={() => handleExport("pdf")}>Exportar PDF</Button>
</div>
);
};
Features:
‚úÖ Exporta√ß√£o Excel (XLSX.js)
‚úÖ Exporta√ß√£o PDF (jsPDF)
‚úÖ Gr√°ficos de distribui√ß√£o por status
‚úÖ Filtro por per√≠odo (m√™s atual, √∫ltimo m√™s, √∫ltimos 3/6 meses, ano)
‚úÖ Detalhamento de receita
9. Rendimento (Performance) ‚ö°
Rota: /performance
C√≥digo:
// src/pages/Performance.tsx
export default function Performance() {
const { records, summary, isLoading } = usePerformance("2025-09");
const filteredRecords = useMemo(() => {
let data = records;
data = filterByPlants(data, selectedPlants);
data = filterByConsumers(data, selectedConsumers);
data = filterByCompensationMode(data, selectedModes);
data = searchRecords(data, searchTerm);
return data;
}, [records, selectedPlants, selectedConsumers, selectedModes, searchTerm]);
return (
<div>
<PerformanceStatsCards summary={summary} />
code
Code
<PerformanceFilters
    selectedPlants={selectedPlants}
    selectedModes={selectedModes}
    onPlantsChange={setSelectedPlants}
    onModesChange={setSelectedModes}
  />
  
  <PerformanceTable records={filteredRecords} />
</div>
);
}
// src/hooks/usePerformance.ts
export function usePerformance(referenceMonth?: string) {
const { data: records } = useQuery({
queryKey: ["performance-records", referenceMonth],
queryFn: async () => {
let query = supabase
.from("performance_records")
.select("*")
.eq("created_by", session.user.id);
code
Code
if (referenceMonth) {
    query = query.eq("reference_month", referenceMonth);
  }
  
  return query.order("reference_month", { ascending: false });
},
staleTime: 180000 // Cache 3min
});
const summary = {
energyGenerated: records.reduce((acc, r) => acc + r.energy_consumed, 0),
energyConsumed: records.reduce((acc, r) => acc + r.energy_consumed, 0),
energyCompensated: records.reduce((acc, r) => acc + r.energy_compensated, 0),
totalBilling: records.reduce((acc, r) => acc + r.billing, 0)
};
return { records, summary, isLoading };
}
Features:
‚úÖ M√©tricas agregadas (energia gerada/consumida/compensada, faturamento)
‚úÖ Filtros por usina, consumidor, modalidade
‚úÖ Tabela detalhada por UC
‚úÖ C√°lculo de economia do consumidor
10. Assistente IA ü§ñ
Rota: /ai-assistant
10.1 Processamento Gen√©rico de Documentos (OpenAI)
C√≥digo Frontend:
// src/components/ai/AIDocumentProcessor.tsx
export function AIDocumentProcessor() {
const processFile = async (file: File) => {
// 1) Upload para bucket "documents" (n√£o "invoices")
const path = ${crypto.randomUUID()}-${file.name};
await supabase.storage.from("documents").upload(path, file);
code
Code
// 2) Chama edge function process-document
const response = await fetch(
  `${VITE_SUPABASE_URL}/functions/v1/process-document`,
  {
    method: "POST",
    body: JSON.stringify({
      bucket: "documents",
      path,
      size: file.size,
      contentType: file.type
    })
  }
);

const result = await response.json();
// result = { type: "energy_invoice" | "contract" | "id_document" | "generic", confidence: 0.95 }
};
return (
<Card>
<input type="file" multiple onChange={handleFileChange} />
<Button onClick={handleUploadAndProcess}>Enviar e Processar</Button>
code
Code
{processing.map(item => (
    <div>
      {item.status === "success" && <CheckCircle />}
      {item.status === "error" && <XCircle />}
      <span>{item.fileName}</span>
      <span>{item.message}</span>
    </div>
  ))}
</Card>
);
}
Edge Function:
// supabase/functions/process-document/index.ts (resumido - 476 linhas)
serve(async (req) => {
const { bucket, path, size, contentType } = await req.json();
// PROTE√á√ÉO CONTRA LOOPS: verifica se j√° est√° processando ou processado
const { data: existingDocs } = await supabaseAdmin
.from("documents")
.select("id, processing, document_extractions(id)")
.eq("bucket", bucket)
.eq("path", path);
if (existingDocs[0]?.processing) {
return json({ ok: true, message: "Already processing" });
}
if (existingDocs[0]?.document_extractions?.length > 0) {
return json({ ok: true, message: "Already processed" });
}
// 1) Download do storage
const fileData = await supabaseAdmin.storage.from(bucket).download(path);
// 2) Insere em documents com processing=true
const { data: docRow } = await supabaseAdmin
.from("documents")
.insert({ bucket, path, processing: true, uploaded_by: userId })
.select().single();
currentProcessingDocId = docRow.id; // Para cleanup no finally
// 3) Converte para base64
const ab = await fileData.arrayBuffer();
const b64 = btoa(String.fromCharCode(...new Uint8Array(ab)));
// 4) Chama OpenAI com timeout 120s + 2 retries
const prompt = Analise este documento e retorne: { "doc_type": "energy_invoice" | "contract" | "id_document" | "generic", "confidence": 0-1 };
const aiResponse = await withRetryAndTimeout(
() => fetch("https://api.openai.com/v1/chat/completions", {
method: "POST",
headers: { "Authorization": Bearer ${OPENAI_API_KEY} },
body: JSON.stringify({
model: "gpt-4o-mini",
messages: [{
role: "user",
content: [
{ type: "text", text: prompt },
{ type: "image_url", image_url: { url: data:${contentType};base64,${b64} }}
]
}],
max_completion_tokens: 500
})
}),
{ maxRetries: 2, timeout: 120000 }
);
const result: ExtractionResult = JSON.parse(aiResponse.choices[0].message.content);
// 5) Salva em document_extractions
await supabaseAdmin.from("document_extractions").insert({
document_id: docRow.id,
doc_type: result.doc_type,
confidence: result.confidence,
json_data: result
});
// 6) FINALLY: sempre reseta processing=false (mesmo em erro)
await supabaseAdmin
.from("documents")
.update({ processing: false })
.eq("id", currentProcessingDocId);
return json({ ok: true, type: result.doc_type, confidence: result.confidence });
});
Features:
‚úÖ Processamento gen√©rico com OpenAI GPT-4o-mini
‚úÖ Classifica√ß√£o: energy_invoice, contract, id_document, generic
‚úÖ Prote√ß√£o contra loops infinitos (verifica se j√° est√° processando)
‚úÖ Retry autom√°tico (2 tentativas) + timeout 120s
‚úÖ Cleanup garantido com finally block
‚úÖ Suporte: PDF, PNG, JPG, WEBP
10.2 Data Copilot (SQL Natural)
C√≥digo:
// src/components/ai/DataCopilot.tsx
export function DataCopilot() {
const handleAsk = async () => {
const response = await fetch(
${VITE_SUPABASE_URL}/functions/v1/data-chat,
{
method: "POST",
body: JSON.stringify({ question })
}
);
code
Code
const result = await response.json();
// result = { sql: "SELECT ...", columns: ["name", "value"], rows: [{...}] }

setSql(result.sql);
setColumns(result.columns);
setRows(result.rows);
};
return (
<Card>
<Textarea
value={question}
placeholder="Ex: Qual o total faturado por distribuidora em 2024?"
/>
<Button onClick={handleAsk}>Perguntar</Button>
code
Code
<Collapsible>
    <CollapsibleTrigger>Ver SQL gerado</CollapsibleTrigger>
    <CollapsibleContent>
      <pre>{sql}</pre>
    </CollapsibleContent>
  </Collapsible>
  
  <Table>
    <TableHeader>
      {columns.map(col => <TableHead>{col}</TableHead>)}
    </TableHeader>
    <TableBody>
      {rows.map(row => (
        <TableRow>
          {columns.map(col => <TableCell>{row[col]}</TableCell>)}
        </TableRow>
      ))}
    </TableBody>
  </Table>
</Card>
);
}
Edge Function:
// supabase/functions/data-chat/index.ts (resumido)
serve(async (req) => {
const { question } = await req.json();
// 1) Sanitiza√ß√£o de SQL (evita UPDATE/DELETE/DROP)
const dangerousPatterns = [
/\bupdate\b/i, /\bdelete\b/i, /\bdrop\b/i, /\binsert\b/i,
/\balter\b/i, /\btruncate\b/i, /\b--/
];
// 2) Chama Lovable AI para gerar SQL
const prompt = Gere SQL para: "${question}". Tabelas dispon√≠veis: consumers, units, plants, invoices, billing_records. Retorne APENAS o SQL, sem explica√ß√µes.;
const aiResponse = await fetch("https://ai.gateway.lovable.dev/v1/chat/completions", {
method: "POST",
body: JSON.stringify({
model: "google/gemini-2.5-flash",
messages: [{ role: "user", content: prompt }]
})
});
const sqlGenerated = aiResponse.choices[0].message.content.trim();
// 3) Valida SQL gerado
if (dangerousPatterns.some(pattern => pattern.test(sqlGenerated))) {
throw new Error("SQL perigoso detectado");
}
// 4) Executa via fun√ß√£o PL/pgSQL execute_sql()
const { data } = await supabase.rpc("execute_sql", { query: sqlGenerated });
const columns = data.length > 0 ? Object.keys(data[0]) : [];
return json({ sql: sqlGenerated, columns, rows: data });
});
Features:
‚úÖ Consultas em linguagem natural
‚úÖ Gera√ß√£o de SQL com Lovable AI
‚úÖ Sanitiza√ß√£o rigorosa (bloqueia UPDATE/DELETE/DROP)
‚úÖ Whitelist de tabelas
‚úÖ Visualiza√ß√£o do SQL gerado
‚úÖ Tabela interativa com resultados
üîê Seguran√ßa (RLS Policies)
Exemplo de Pol√≠ticas:
-- consumers: qualquer autenticado pode CRUD (‚ö†Ô∏è precisa filtrar por created_by via units)
CREATE POLICY owner_can_select_consumers ON consumers FOR SELECT TO authenticated USING (true);
CREATE POLICY owner_can_insert_consumers ON consumers FOR INSERT TO authenticated WITH CHECK (true);
-- units: filtro por created_by
CREATE POLICY owner_can_select_units ON units FOR SELECT TO authenticated
USING (auth.uid() = created_by);
CREATE POLICY owner_can_update_units ON units FOR UPDATE TO authenticated
USING (auth.uid() = created_by);
-- invoices: sem filtro (‚ö†Ô∏è todos autenticados veem tudo)
CREATE POLICY invoices_select_all ON invoices FOR SELECT TO authenticated USING (true);
CREATE POLICY invoices_update_all ON invoices FOR UPDATE TO authenticated USING (true);
-- documents: sem filtro de usu√°rio (‚ö†Ô∏è cross-user access)
CREATE POLICY all_read_documents_table ON documents FOR SELECT TO authenticated USING (true);
‚ö†Ô∏è PROBLEMAS DE SEGURAN√áA IDENTIFICADOS (n√£o corrigidos conforme solicita√ß√£o):
consumers: RLS permite acesso cross-user (deveria filtrar via units.created_by)
documents: Sem filtro uploaded_by = auth.uid(), permite ver documentos de outros usu√°rios
Leaked Password Protection: Desabilitado no Supabase Auth
üìä Performance & Otimiza√ß√µes
√çndices Criados (9 √≠ndices):
-- Fase 3: Performance improvements
CREATE INDEX idx_invoices_created_by ON invoices(created_by);
CREATE INDEX idx_invoices_reference ON invoices(reference_year, reference_month);
CREATE INDEX idx_documents_uploaded_by ON documents(uploaded_by);
CREATE INDEX idx_documents_processing ON documents(processing);
CREATE INDEX idx_billing_status ON billing_records(status);
CREATE INDEX idx_billing_created_by ON billing_records(created_by);
CREATE INDEX idx_performance_created_by ON performance_records(created_by);
CREATE INDEX idx_performance_reference ON performance_records(reference_month);
CREATE INDEX idx_units_created_by ON units(created_by);
CREATE INDEX idx_plants_created_by ON plants(created_by);
React Query Cache:
// Configura√ß√£o de staleTime (cache) por hook:
useConsumers ‚Üí 120s (2min)
usePlants ‚Üí 180s (3min)
useUnits ‚Üí 120s (2min)
useInvoices ‚Üí 60s (1min)
usePerformance ‚Üí 180s (3min)
Dashboard ‚Üí 30s
// Retry autom√°tico:
retry: 2 // Todas as queries tentam 2 vezes antes de falhar
Query Optimization:
// ANTES (N+1 query problem):
.select(", invoice:invoices(, unit:units(, consumer:consumers()))")
// DEPOIS (campos espec√≠ficos):
.select(id, created_at, status, invoice:invoices(due_date, amount_total, unit:units(uc_number)), consumer:consumers(document))
üõ†Ô∏è Edge Functions (8 fun√ß√µes)
Resumo:
extract-invoice-data ‚Üí Extra√ß√£o de faturas com Lovable AI (Gemini)
process-document ‚Üí Processamento gen√©rico com OpenAI
data-chat ‚Üí SQL natural com Lovable AI
send-custom-invoice ‚Üí Envio de email com 2 anexos
send-distributor-invoice ‚Üí Envio de fatura da distribuidora
_shared/lib/clients.ts ‚Üí Cliente Supabase compartilhado
_shared/lib/storage-utils.ts ‚Üí Download e base64 (deduplicated)
_shared/lib/retry-utils.ts ‚Üí withRetry, withTimeout, withRetryAndTimeout
Bibliotecas Compartilhadas:
// supabase/functions/shared/lib/retry-utils.ts
export async function withRetryAndTimeout<T>(
fn: () => Promise<T>,
options: { maxRetries: number; timeout: number }
): Promise<T> {
for (let attempt = 1; attempt <= options.maxRetries; attempt++) {
try {
const timeoutPromise = new Promise<never>((, reject) =>
setTimeout(() => reject(new Error("Timeout")), options.timeout)
);
return await Promise.race([fn(), timeoutPromise]);
} catch (err) {
if (attempt < options.maxRetries) {
await new Promise(resolve => setTimeout(resolve, attempt * 3000));
} else {
throw err;
}
}
}
}
// supabase/functions/_shared/lib/storage-utils.ts
export async function downloadFileAsBase64(
supabase: SupabaseClient,
bucket: string,
path: string
): Promise<string> {
const { data, error } = await supabase.storage.from(bucket).download(path);
if (error) throw error;
const ab = await data.arrayBuffer();
return btoa(String.fromCharCode(...new Uint8Array(ab)));
}
üé® UI Components (shadcn/ui)
Componentes Principais:
Button, Input, Textarea, Label
Card, CardHeader, CardTitle, CardContent
Table, TableHeader, TableBody, TableRow, TableCell
Dialog, AlertDialog, Sheet
Select, Checkbox, Switch, RadioGroup
Tabs, Accordion, Collapsible
Toast, Sonner (notifica√ß√µes)
Skeleton (loading states)
Badge, Avatar, Progress
Pagination, Dropdown, Popover
Calendar, DatePicker
üîÑ Fluxo Completo de Faturamento
graph TD
A[Upload de Fatura PDF] --> B[C√°lculo SHA256]
B --> C[Upload para Storage invoices/]
C --> D[INSERT em invoices com status=uploaded]
D --> E[Dispara extract-invoice-data]
E --> F[Download PDF + Converte Base64]
F --> G[Chamada Lovable AI Gemini 2.5 Flash]
G --> H[Extra√ß√£o de dados: UC, distribuidora, valores]
H --> I[UPDATE invoices com parsed JSONB + status=parsed]
I --> J[Frontend: P√°gina de Envio de Emails]
J --> K[Usu√°rio seleciona faturas + customiza mensagem]
K --> L[Dispara send-custom-invoice]
L --> M[Busca 2 faturas: proprietary + distributor]
M --> N[Baixa PDFs + Converte Base64]
N --> O[Valida√ß√£o de tamanho total < 25MB]
O --> P[Envio via Resend com 2 anexos]
P --> Q[INSERT em email_history]
Q --> R[UPDATE billing_records status=sent]
üìù Tipos TypeScript
Principais Tipos:
// src/types/invoice.ts
export type InvoiceType = "solar" | "distributor" | "generation";
export type InvoiceEntityType = "plant" | "unit";
export interface Invoice {
id: string;
entityType: InvoiceEntityType;
entityId: string;
entityName: string;
referenceMonth: string; // "YYYY-MM"
invoiceType: InvoiceType;
fileName: string;
fileUrl: string;
fileSize: number;
uploadedAt: string;
}
// src/types/billing.ts
export type BillingStatus = "pending" | "paid" | "overdue" | "sent" | "not_billed";
export interface BillingRecord {
id: string;
unitName: string;
clientNumber: string;
sendDate: string;
dueDate: string;
amountDue: number;
status: BillingStatus;
solarBillUrl: string;
distributorBillUrl: string;
}
// src/types/consumer.ts
export interface Consumer {
id: string;
name: string;
email?: string | null;
phone?: string | null;
document?: string | null;
created_at?: string;
}
üöÄ Como Funciona na Pr√°tica
Fluxo do Usu√°rio:
Login ‚Üí /auth (Supabase Auth)
Dashboard ‚Üí V√™ m√©tricas gerais, faturas recentes, alertas
Cadastros ‚Üí Cria consumidores, unidades, usinas
Upload de Faturas ‚Üí /billing/upload-invoices
Arrasta PDF da ENEL
Seleciona UC, m√™s de refer√™ncia, tipo
IA extrai automaticamente: valor, vencimento, kWh, bandeira
Envio de Emails ‚Üí /send-emails
Filtra faturas pendentes
Seleciona m√∫ltiplas faturas
Customiza mensagem
Envia em lote com 2 anexos (ENEL + Demonstrativo)
Relat√≥rios ‚Üí /reports
Visualiza estat√≠sticas
Exporta Excel/PDF
üéØ Diferenciais do Sistema
‚úÖ IA Integrada: Extra√ß√£o autom√°tica de dados de faturas (sem digita√ß√£o manual)
‚úÖ Multi-tenant: Cada usu√°rio v√™ apenas seus dados (RLS)
‚úÖ Escal√°vel: Supabase Cloud + Edge Functions serverless
‚úÖ Performance: Cache inteligente, √≠ndices otimizados, retry autom√°tico
‚úÖ Email Transacional: Resend com anexos m√∫ltiplos
‚úÖ Deduplica√ß√£o: SHA256 evita uploads duplicados
‚úÖ Error Handling: Tratamento de rate limits, timeouts, cr√©ditos
‚úÖ UX Moderno: shadcn/ui + Tailwind CSS